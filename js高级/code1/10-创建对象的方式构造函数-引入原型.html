<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <title>标题</title>
  <script>
    //1.构造函数创建对象.
    //1.1 把方法体放在构造函数体中. 造成的问题是每一个实例化的对象,都有一个这样的方法,浪费内存空间的问题.
    //  function Student(name,age){
    //    this.name = name;
    //    this.age = age;
    //    this.sayHi = function () {
    //      console.log("我的名字是:"+this.name+",我的年龄是:"+this.age);
    //    }
    //  }
    //  //创建2个学生对象
    //  var s1 = new Student('欧阳娜娜',18);
    //  s1.sayHi();
    //  var s2 = new Student('区志玲',19);
    //  s2.sayHi();
    //  //console.log(s1.sayHi); //输出的是函数本身
    //  console.log(s1.sayHi === s2.sayHi); //false



    //1.2 解决办法.
    //把方法体给 提炼出来.
    //新的问题: 会造成全局变量污染的问题. 怎么办?
    // function test1(){
    //   console.log("我的名字是:"+this.name+",我的年龄是:"+this.age);
    // }
    // function Student(name,age){
    //   this.name = name;
    //   this.age = age;
    //   this.sayHi = test1;
    // }
    // // function test1(){
    // //
    // // }
    // // function Teacher(){
    // //   this.sayHi = test1;
    // // }
    // //创建2个学生对象
    // var s1 = new Student('彭爽',28);
    // s1.sayHi();
    // var s2 = new Student('彭娜',17);
    // s2.sayHi();
    // console.log(s1.sayHi === s2.sayHi); //true.



    //1.3 解决办法,把提炼出来的方法写在对象中.
    //这样还有一点不爽:  每次声明一个构造函数,都要给他额外配一个对象.
    // var obj1 = {
    //   test1: function () {
    //     console.log("我的名字是:"+this.name+",我的年龄是:"+this.age);
    //   }
    // }
    // function Student(name,age){
    //   this.name = name;
    //   this.age = age;
    //   this.sayHi = obj1.test1;
    // }



    //1.4 就想: 有没有一个东西,能够代替这个额外配的对象呢? 不需要我们手动声明呢?
    //有,原型.


    //--------------------------------------------------------------------------------------------
     function Student(name,age){
       this.name = name;
       this.age = age;
     }
    //4.1 原型
    //不管是那个构造函数被创建,系统都会自动的帮我们生成一个与之对应的对象,这个对象就是原型.

    //4.2 如何访问这个原型.
    //构造函数名.prototype.
    //console.log(Student.prototype);


    //4.3 既然原型是一个对象,请问可不可以给他添加属性和方法.
    Student.prototype.aaa = 'aaa';
    Student.prototype['bbb'] = function () {
      console.log("bbb");
    }
    //console.log(Student.prototype);


    //4.4 谁能够访问原型中添加的属性和方法.
    //原型对应的构造函数实例化的对象们.
    var s1 = new Student("刘龙明",40);
    var s2 = new Student('王成',38);
    // console.log(s1.aaa);
    // s2.bbb();

    console.log(s1.bbb === s2.bbb); //true


  </script>
</head>
<body>

</body>
</html>